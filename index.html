<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è»Šç‰Œè¾¨è­˜ç³»çµ± (æŠ—å¹²æ“¾å„ªåŒ–ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        body { font-family: "Microsoft JhengHei", sans-serif; text-align: center; padding: 10px; background: #1a1a1a; color: white; }
        
        #video-container { 
            position: relative; margin: 0 auto; 
            width: 100%; max-width: 640px; height: 400px;
            background: #000; overflow: hidden; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* æƒææ¡† */
        .scan-region {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            width: 80%; height: 25%; 
            border: 3px solid #00ff00; border-radius: 8px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7); /* åŠ æ·±å‘¨åœæš—åº¦ */
            z-index: 10;
        }
        .scan-label {
            position: absolute; top: -30px; left: 0; width: 100%;
            color: #00ff00; font-weight: bold; font-size: 14px; text-shadow: 1px 1px 2px black;
        }

        .controls { margin-top: 15px; }
        button {
            padding: 12px 20px; font-size: 16px; border: none; border-radius: 8px;
            background-color: #007bff; color: white; cursor: pointer; margin: 8px;
        }
        button:disabled { background-color: #444; color: #888; }
        button.scan-btn { background-color: #28a745; width: 70%; padding: 18px; font-size: 1.3em; font-weight: bold;}

        #result-area { margin-top: 15px; padding: 15px; background: #333; border-radius: 10px; min-height: 80px; }
        .ocr-raw { color: #888; font-size: 0.8em; margin-bottom: 8px; word-break: break-all; }
        
        .match-success { color: #4dff4d; font-size: 1.8em; font-weight: 900; }
        .match-fail { color: #ff4d4d; font-size: 1.5em; font-weight: 900; }

        #debug-container { margin-top: 20px; border-top: 1px dashed #555; padding-top: 10px; }
        #processedCanvas { border: 1px solid #666; width: 180px; height: auto; background: #000; display: block; margin: 0 auto; }
    </style>
</head>
<body>

    <h3>ğŸ›¡ï¸ è»Šç‰Œè¾¨è­˜ (æŠ—è²¼ç´™å¹²æ“¾ç‰ˆ)</h3>
    <div id="dbStatus" style="font-size: 12px; color: #aaa;">è³‡æ–™åº«è¼‰å…¥ä¸­...</div>

    <div id="video-container">
        <video id="video" playsinline autoplay muted></video>
        <div class="scan-region">
            <div class="scan-label">è«‹å°‡è»Šç‰Œç½®æ–¼æ¡†å…§</div>
        </div>
    </div>

    <div class="controls">
        <button id="startBtn">1. å•Ÿå‹•ç›¸æ©Ÿ</button>
        <br>
        <button id="scanBtn" class="scan-btn" disabled>ğŸ“¸ æ™ºæ…§è¾¨è­˜</button>
    </div>

    <div id="result-area">
        <div id="ocrRaw" class="ocr-raw"></div>
        <div id="statusMsg">ç­‰å¾…æ“ä½œ...</div>
    </div>

    <div id="debug-container">
        <div style="font-size:10px; color:#aaa; margin-bottom:5px;">é›»è…¦åˆ¤å®šå½±åƒ:</div>
        <canvas id="processedCanvas"></canvas>
    </div>

    <script>
        let whitelistArray = [];
        const video = document.getElementById('video');
        const startBtn = document.getElementById('startBtn');
        const scanBtn = document.getElementById('scanBtn');
        const statusMsg = document.getElementById('statusMsg');
        const ocrRawMsg = document.getElementById('ocrRaw');
        const dbStatus = document.getElementById('dbStatus');
        const processedCanvas = document.getElementById('processedCanvas');

        async function loadWhitelist() {
            try {
                const response = await fetch('whitelist.txt');
                if (!response.ok) throw new Error("æ‰¾ä¸åˆ°æª”æ¡ˆ");
                const text = await response.text();
                // è¼‰å…¥æ™‚å°‡æ©«ç·šæ‹¿æ‰ï¼Œçµ±ä¸€æ ¼å¼
                whitelistArray = text.split(/\r?\n/)
                    .map(line => line.trim().replace(/[^a-zA-Z0-9]/g, '').toUpperCase())
                    .filter(item => item.length > 0);
                dbStatus.textContent = `âœ… è³‡æ–™åº«ï¼š${whitelistArray.length} ç­†`;
            } catch (err) {
                dbStatus.textContent = "âŒ è³‡æ–™åº«è¼‰å…¥å¤±æ•—";
            }
        }
        loadWhitelist();

        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    scanBtn.disabled = false;
                    startBtn.style.display = 'none';
                    statusMsg.textContent = "æº–å‚™å°±ç·’";
                };
            } catch (err) {
                alert("ç›¸æ©ŸéŒ¯èª¤ï¼š" + err.message);
            }
        });

        function captureAndProcessImage() {
            const ctx = processedCanvas.getContext('2d');
            const vw = video.videoWidth;
            const vh = video.videoHeight;
            
            // è£åˆ‡ï¼šç¨å¾®ç¸®å°ä¸€é»ç¯„åœï¼Œé¿å…æ¡†æ¡†é‚Šç·£å…¥é¡
            const cropW = vw * 0.8; 
            const cropH = cropW * 0.3; 
            const cropX = (vw - cropW) / 2;
            const cropY = (vh - cropH) / 2;

            processedCanvas.width = cropW;
            processedCanvas.height = cropH;

            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

            let imageData = ctx.getImageData(0, 0, cropW, cropH);
            let data = imageData.data;

            // å¢å¼·å°æ¯” (High Contrast)
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.3 + data[i + 1] * 0.59 + data[i + 2] * 0.11;
                // é–€æª»å€¼ 105ï¼Œå¯è¦–æƒ…æ³å¾®èª¿
                const value = gray > 105 ? 255 : 0; 
                data[i] = data[i + 1] = data[i + 2] = value;
            }
            ctx.putImageData(imageData, 0, 0);
            return processedCanvas.toDataURL('image/png');
        }

        // --- å„ªåŒ–æ ¸å¿ƒï¼šæ™ºæ…§ç¯©é¸èˆ‡ä¿®æ­£ ---
        function extractPotentialPlates(rawText) {
            // 1. å°‡è®€åˆ°çš„æ‰€æœ‰æ–‡å­—ç”¨ ç©ºç™½ æˆ– æ›è¡Œ åˆ‡é–‹
            // ä¾‹å¦‚: "TOYOTA Baby-in-car ABC-1234" -> ["TOYOTA", "Baby-in-car", "ABC-1234"]
            const tokens = rawText.split(/[\s\n]+/);
            
            let candidates = [];

            tokens.forEach(token => {
                // æ¸…ç†é›œè¨Šï¼Œåªç•™è‹±æ•¸
                let cleanToken = token.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();

                // 2. å°ç£è»Šç‰Œéæ¿¾é‚è¼¯ï¼š
                // é•·åº¦å¿…é ˆåœ¨ 4 åˆ° 8 ä¹‹é–“ (éçŸ­é€šå¸¸æ˜¯é›œè¨Šï¼Œéé•·é€šå¸¸æ˜¯æ¨™èª)
                if (cleanToken.length < 4 || cleanToken.length > 8) return;

                // 3. å¿…é ˆåŒæ™‚åŒ…å«ã€Œæ•¸å­—ã€èˆ‡ã€Œå­—æ¯ã€ (é¿å…æŠŠ "TAX" æˆ– "2024" èª¤èªç‚ºè»Šç‰Œ)
                // å‚™è¨»ï¼šæœ‰äº›èˆŠå¼è»Šç‰Œå…¨æ˜¯æ•¸å­—ï¼Œå¦‚æœæ‚¨çš„å ´åŸŸæœ‰é€™ç¨®è»Šï¼Œè«‹ç§»é™¤é€™è¡Œ
                const hasNumber = /[0-9]/.test(cleanToken); 
                // const hasLetter = /[A-Z]/.test(cleanToken); // è‹¥éœ€è¦å¼·åˆ¶åŒ…å«è‹±æ–‡å¯æ‰“é–‹

                if (hasNumber) {
                    // 4. é€²è¡Œæ¨¡ç³Šä¿®æ­£ (Z->2, O->0)
                    let fuzzyFixed = cleanToken
                        .replace(/Z/g, '2')
                        .replace(/O/g, '0')
                        .replace(/D/g, '0')
                        .replace(/Q/g, '0')
                        .replace(/B/g, '8')
                        .replace(/I/g, '1');
                    
                    candidates.push(fuzzyFixed);
                }
            });

            return candidates;
        }

        scanBtn.addEventListener('click', async () => {
            statusMsg.textContent = "â³ æ™ºæ…§åˆ†æä¸­...";
            ocrRawMsg.textContent = "";
            const dataUrl = captureAndProcessImage();

            try {
                const { data: { text } } = await Tesseract.recognize(dataUrl, 'eng', {
                    // â˜… é—œéµå„ªåŒ– 1: ä½¿ç”¨ PSM 7 (è¦–ç‚ºå–®è¡Œæ–‡å­—)ï¼Œæ¸›å°‘å°å¤šè¡Œæ–‡å­—çš„èª¤åˆ¤
                    tessedit_pageseg_mode: '7', 
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789- ' // å…è¨±ç©ºæ ¼èˆ‡æ©«ç·šä»¥åˆ©åˆ‡åˆ†
                });

                ocrRawMsg.textContent = `åŸå§‹æƒæ: ${text}`;

                // â˜… é—œéµå„ªåŒ– 2: æå–æ½›åœ¨è»Šç‰Œ (æ’é™¤è²¼ç´™)
                const candidates = extractPotentialPlates(text);
                
                if (candidates.length === 0) {
                    statusMsg.innerHTML = "âš ï¸ æ‰¾ä¸åˆ°åƒè»Šç‰Œçš„æ–‡å­—<br><span style='font-size:0.6em'>è«‹é è¿‘ä¸€é»æˆ–é¿é–‹åå…‰</span>";
                    return;
                }

                console.log("éæ¿¾å¾Œçš„å€™é¸åå–®:", candidates);

                // 3. æ¯”å°è³‡æ–™åº«
                let foundMember = null;
                
                // åªè¦ä»»ä½•ä¸€å€‹ã€Œå€™é¸å­—ä¸²ã€å‡ºç¾åœ¨ã€Œè³‡æ–™åº«ã€ä¸­ (æˆ–åä¹‹)
                for (let candidate of candidates) {
                    for (let memberPlate of whitelistArray) {
                        // é›™å‘æ¯”å°ï¼šè§£æ±º OCR å¤šè®€ä¸€ç¢¼æˆ–å°‘è®€ä¸€ç¢¼çš„å•é¡Œ
                        if (candidate.includes(memberPlate) || memberPlate.includes(candidate)) {
                            // åš´æ ¼æª¢æŸ¥ï¼šé•·åº¦å·®ç•°ä¸èƒ½å¤ªå¤§ (é¿å… 123 å°ä¸Š 12345)
                            if (Math.abs(candidate.length - memberPlate.length) <= 1) {
                                foundMember = memberPlate;
                                break;
                            }
                        }
                    }
                    if (foundMember) break;
                }

                if (foundMember) {
                    statusMsg.innerHTML = `<div class="match-success">â­• æœƒå“¡ç¢ºèª<br>${foundMember}</div>`;
                } else {
                    statusMsg.innerHTML = `<div class="match-fail">âŒ éæœƒå“¡<br>${candidates[0]}</div>`; // é¡¯ç¤ºæœ€åƒçš„é‚£å€‹
                }

            } catch (err) {
                console.error(err);
                statusMsg.textContent = "âŒ éŒ¯èª¤";
            }
        });
    </script>
</body>
</html>
