<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è»Šç‰Œè¾¨è­˜ (å»£è§’å®¹éŒ¯ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        body { font-family: "Microsoft JhengHei", sans-serif; text-align: center; padding: 10px; background: #000; color: white; }
        
        #video-container { 
            position: relative; margin: 0 auto; 
            width: 100%; max-width: 640px; height: 400px;
            background: #111; overflow: hidden; border-radius: 12px;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* æƒææ¡†ï¼šæ”¹ç‚ºè™›ç·šï¼Œä¸¦ç¨å¾®åŠ å¤§ï¼Œå…è¨±ä¸€é»é»è§’åº¦åå·® */
        .scan-region {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            width: 85%; height: 30%; 
            border: 2px dashed #00ff00; border-radius: 6px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }
        
        .controls { margin-top: 15px; }
        button {
            padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px;
            background-color: #444; color: white; cursor: pointer; margin: 5px;
        }
        button.scan-btn { background-color: #28a745; width: 80%; padding: 15px; font-size: 1.2em; font-weight: bold; }
        button:disabled { background-color: #222; color: #555; }

        #result-area { margin-top: 15px; padding: 10px; background: #222; border-radius: 8px; min-height: 60px; }
        .match-success { color: #4dff4d; font-size: 1.8em; font-weight: bold; }
        .match-fail { color: #ff4d4d; font-size: 1.2em; }
        .debug-info { color: #888; font-size: 0.8em; margin-top: 5px; }

        /* é™¤éŒ¯ç•«å¸ƒ */
        #processedCanvas { border: 1px solid #444; width: 200px; display: block; margin: 10px auto; background: black; }
    </style>
</head>
<body>

    <h3>ğŸ›¡ï¸ è»Šç‰Œè¾¨è­˜ (å¼·æ•ˆå®¹éŒ¯ç‰ˆ)</h3>
    <div id="dbStatus" style="font-size: 12px; color: #aaa;">è³‡æ–™åº«è¼‰å…¥ä¸­...</div>

    <div id="video-container">
        <video id="video" playsinline autoplay muted></video>
        <div class="scan-region"></div>
    </div>

    <div class="controls">
        <button id="startBtn">å•Ÿå‹•ç›¸æ©Ÿ</button>
        <br>
        <button id="scanBtn" class="scan-btn" disabled>ğŸ“¸ è¾¨è­˜</button>
    </div>

    <div id="result-area">
        <div id="statusMsg">ç­‰å¾…æ“ä½œ...</div>
        <div id="debugRaw" class="debug-info"></div>
    </div>

    <canvas id="processedCanvas"></canvas>

    <script>
        let whitelistArray = [];
        const video = document.getElementById('video');
        const startBtn = document.getElementById('startBtn');
        const scanBtn = document.getElementById('scanBtn');
        const statusMsg = document.getElementById('statusMsg');
        const debugRaw = document.getElementById('debugRaw');
        const dbStatus = document.getElementById('dbStatus');
        const processedCanvas = document.getElementById('processedCanvas');

        // å®šç¾©ã€Œæ˜“æ··æ·†å­—å…ƒã€å°æ‡‰è¡¨
        // è¦å‰‡ï¼šå¦‚æœæˆ‘çœ‹ä¸åˆ° Aï¼Œä½†æˆ‘çœ‹åˆ° Bï¼Œä¸” A å’Œ B åœ¨è¡¨è£¡æ˜¯å…„å¼Ÿï¼Œé‚£å°±ç•¶ä½œæˆ‘çœ‹å°äº†
        const CONFUSABLE_MAP = {
            '4': ['6', 'A'],    // 4 å®¹æ˜“è¢«çœ‹æˆ 6 æˆ– A
            '6': ['4', 'G', '8', '0'], // 6 å®¹æ˜“è¢«çœ‹æˆ 4, G, 8, 0
            'Z': ['2', '7'],
            '2': ['Z'],
            'B': ['8', 'D'],
            '8': ['B', '3'],
            'D': ['0', 'O', 'Q'],
            '0': ['D', 'O', 'Q'],
            'O': ['0', 'D', 'Q'],
            'Q': ['0', 'D', 'O'],
            'S': ['5'],
            '5': ['S'],
            'I': ['1', 'T'],
            '1': ['I', 'T'],
            'T': ['1', '7', 'I']
        };

        async function loadWhitelist() {
            try {
                const response = await fetch('whitelist.txt');
                if (!response.ok) throw new Error("æ‰¾ä¸åˆ° whitelist.txt");
                const text = await response.text();
                whitelistArray = text.split(/\r?\n/)
                    .map(line => line.trim().replace(/[^a-zA-Z0-9]/g, '').toUpperCase())
                    .filter(item => item.length > 0);
                dbStatus.textContent = `âœ… è³‡æ–™åº«ï¼š${whitelistArray.length} ç­†`;
            } catch (err) {
                dbStatus.textContent = "âŒ è³‡æ–™åº«è¼‰å…¥å¤±æ•—";
            }
        }
        loadWhitelist();

        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => { video.play(); scanBtn.disabled = false; startBtn.style.display = 'none'; };
            } catch (err) { alert("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—"); }
        });

        // --- å½±åƒè™•ç†ï¼šè‡ªå‹•è‰²éš (Auto Levels) ---
        // é€™èƒ½è§£æ±ºç”±ä¸Šå¾€ä¸‹æ‹æ™‚ï¼Œä¸Šæ–¹å¤ªäº®ä¸‹æ–¹å¤ªæš—çš„å•é¡Œ
        function captureAndProcessImage() {
            const ctx = processedCanvas.getContext('2d');
            const vw = video.videoWidth;
            const vh = video.videoHeight;
            
            // è£åˆ‡
            const cropW = vw * 0.8; 
            const cropH = cropW * 0.35; 
            const cropX = (vw - cropW) / 2;
            const cropY = (vh - cropH) / 2;

            processedCanvas.width = cropW;
            processedCanvas.height = cropH;
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

            let imageData = ctx.getImageData(0, 0, cropW, cropH);
            let data = imageData.data;

            // 1. å°‹æ‰¾ç•«é¢ä¸­çš„æœ€äº®èˆ‡æœ€æš—é» (Auto Levels)
            let min = 255;
            let max = 0;
            for (let i = 0; i < data.length; i += 4) {
                // è½‰ç°éš
                const gray = data[i] * 0.3 + data[i + 1] * 0.59 + data[i + 2] * 0.11;
                if (gray < min) min = gray;
                if (gray > max) max = gray;
            }

            // 2. æ‹‰ä¼¸å°æ¯”åº¦ä¸¦äºŒå€¼åŒ–
            // é¿å…é™¤ä»¥0
            if (max === min) max = min + 1;
            
            for (let i = 0; i < data.length; i += 4) {
                let gray = data[i] * 0.3 + data[i + 1] * 0.59 + data[i + 2] * 0.11;
                
                // æ­£è¦åŒ–ï¼šå°‡äº®åº¦æ‹‰ä¼¸åˆ° 0~255
                let normalized = (gray - min) / (max - min) * 255;
                
                // ä½¿ç”¨ä¸­ä½æ•¸ 128 ä½œç‚ºé–€æª»
                let value = normalized > 130 ? 255 : 0;

                data[i] = data[i + 1] = data[i + 2] = value;
            }

            ctx.putImageData(imageData, 0, 0);
            return processedCanvas.toDataURL('image/png');
        }

        // --- æ ¸å¿ƒæ¼”ç®—æ³•ï¼šå®¹éŒ¯æ¯”å° (Fuzzy Matcher) ---
        // æ¯”è¼ƒå…©å€‹å­—ä¸²ï¼Œå…è¨±ç‰¹å®šçš„éŒ¯èª¤
        function isMatch(scanned, reference) {
            // é•·åº¦å·®ç•°å¤ªå¤§ç›´æ¥å‡ºå±€
            if (Math.abs(scanned.length - reference.length) > 1) return false;

            // å¦‚æœå­—ä¸²åŒ…å« reference (ä¾‹å¦‚ scanned="TABC1234" åŒ…å« "ABC1234")
            if (scanned.includes(reference)) return true;

            // é€å­—æ¯”å°
            let errorCount = 0;
            let i = 0; // scanned index
            let j = 0; // reference index
            
            // ç°¡å–®çš„é›™æŒ‡é‡æ¯”å°
            while (i < scanned.length && j < reference.length) {
                const charS = scanned[i];
                const charR = reference[j];

                if (charS === charR) {
                    i++; j++;
                } else {
                    // å¦‚æœä¸ç›¸ç­‰ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºã€Œå…è¨±çš„éŒ¯èª¤ã€
                    const allowables = CONFUSABLE_MAP[charR]; // æŸ¥ reference çš„è©²å­—æœ‰å“ªäº›åˆ†èº«
                    if (allowables && allowables.includes(charS)) {
                        // é€™æ˜¯å€‹å¯åŸè«’çš„éŒ¯èª¤ (ä¾‹å¦‚ Ræ˜¯6, Sæ˜¯4)
                        i++; j++; 
                    } else {
                        // é€™æ˜¯å€‹çœŸçš„éŒ¯èª¤
                        errorCount++;
                        i++; j++;
                    }
                }
            }
            
            // å…è¨±æœ€å¤š 1 å€‹ä¸æ˜éŒ¯èª¤ (æˆ–æ˜¯å› ç‚ºé›œè¨Šå¤šä¸€å€‹å­—)
            return errorCount <= 1;
        }

        scanBtn.addEventListener('click', async () => {
            statusMsg.textContent = "â³ é‹ç®—ä¸­...";
            debugRaw.textContent = "";
            
            const dataUrl = captureAndProcessImage();

            try {
                const { data: { text } } = await Tesseract.recognize(dataUrl, 'eng', {
                    tessedit_pageseg_mode: '7',
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789- '
                });

                // 1. æ¸…ç†
                // å°‡æ›è¡Œæˆ–ç©ºæ ¼åˆ‡é–‹ï¼Œå› ç‚ºæœ‰å¯èƒ½æƒæåˆ° "ABC-1234 567" (567æ˜¯é›œè¨Š)
                // æˆ‘å€‘é‡å°æ¯ä¸€å€‹åˆ‡å‡ºä¾†çš„ç‰‡æ®µå»è·Ÿè³‡æ–™åº«æ¯”å°
                const tokens = text.split(/[\s\n]+/);
                
                let foundMember = null;
                let scannedCode = "";

                // 2. é‡å°æ¯ä¸€å€‹ç‰‡æ®µé€²è¡Œæ¯”å°
                for (let rawToken of tokens) {
                    let cleanToken = rawToken.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
                    if (cleanToken.length < 3) continue; // å¤ªçŸ­çš„ä¸çœ‹
                    
                    scannedCode += cleanToken + " ";

                    // éæ­·è³‡æ–™åº«
                    for (let memberPlate of whitelistArray) {
                        if (isMatch(cleanToken, memberPlate)) {
                            foundMember = memberPlate;
                            break;
                        }
                    }
                    if (foundMember) break;
                }

                debugRaw.textContent = `åŸå§‹è­˜åˆ¥: ${text} | æ¸…ç†å¾Œ: ${scannedCode}`;

                if (foundMember) {
                    statusMsg.innerHTML = `<div class="match-success">â­• æœƒå“¡ç¢ºèª<br>${foundMember}</div>`;
                } else {
                    statusMsg.innerHTML = `<div class="match-fail">âŒ æœªæ‰¾åˆ°ç¬¦åˆæœƒå“¡</div>`;
                }

            } catch (err) {
                console.error(err);
                statusMsg.textContent = "âŒ éŒ¯èª¤";
            }
        });
    </script>
</body>
</html>
