<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è»Šç‰Œè¾¨è­˜ (æ””æˆªéæœƒå“¡ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        body { font-family: "Microsoft JhengHei", monospace; text-align: center; padding: 10px; background: #000; color: white; }
        
        #video-container { 
            position: relative; margin: 0 auto; 
            width: 100%; max-width: 640px; height: 360px;
            background: #222; overflow: hidden; border-radius: 8px; border: 1px solid #444;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* æƒææ¡† */
        .scan-region {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            width: 75%; height: 25%; 
            border: 2px solid #00ff00; border-radius: 4px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);
            z-index: 10;
        }

        .controls { margin-top: 10px; }
        button {
            padding: 10px 20px; font-size: 16px; border: none; border-radius: 4px;
            background-color: #444; color: white; cursor: pointer; margin: 5px;
        }
        button.scan-btn { background-color: #28a745; width: 90%; font-size: 1.2em; font-weight: bold; padding: 15px; }
        button:disabled { background-color: #222; color: #555; }

        #result-area { margin-top: 10px; padding: 10px; background: #222; border-radius: 8px; text-align: left; }
        .log-box { font-size: 12px; color: #aaa; height: 100px; overflow-y: scroll; background: #111; padding: 5px; border: 1px solid #333; margin-top: 5px; }
        .raw-text { color: #ffc107; font-size: 1.1em; margin-bottom: 5px; }
        
        .match-success { color: #4dff4d; font-size: 1.6em; font-weight: 900; text-align: center; margin: 10px 0; border: 2px solid #4dff4d; padding: 10px; }
        .match-fail { color: #ff4d4d; font-size: 1.6em; font-weight: 900; text-align: center; margin: 10px 0; border: 2px solid #ff4d4d; padding: 10px; }
        
        #progress-bar { width: 0%; height: 5px; background: #00ff00; transition: width 0.2s; margin-bottom: 5px; }
        
        /* ç¸®å°é è¦½åœ– */
        #processedCanvas { 
            width: 150px; height: auto; border: 1px solid #555; margin-top: 10px; display: block; margin: 0 auto;
        }
    </style>
</head>
<body>

    <h3>ğŸ›¡ï¸ è»Šç‰Œè¾¨è­˜ (æ””æˆªåŠŸèƒ½)</h3>

    <div id="video-container">
        <video id="video" playsinline autoplay muted></video>
        <div class="scan-region"></div>
    </div>

    <div class="controls">
        <button id="startBtn" disabled>â³ è¼‰å…¥ OpenCV...</button>
        <br>
        <button id="scanBtn" class="scan-btn" disabled>ğŸ“¸ é–‹å§‹è¾¨è­˜</button>
    </div>

    <div style="font-size:12px; color:#aaa; margin-top:5px;">AI è¦–è§’:</div>
    <canvas id="processedCanvas"></canvas>

    <div id="result-area">
        <div id="progress-bar"></div>
        <div>OCR è®€å–: <span id="rawText" class="raw-text">---</span></div>
        <div id="statusMsg" style="text-align:center; font-weight:bold;">ç­‰å¾…æ“ä½œ</div>
        <div class="log-box" id="systemLog"><div>[ç³»çµ±] åˆå§‹åŒ–ä¸­...</div></div>
    </div>

    <script>
        // === è¨­å®šå€ ===
        const SUCCESS_THRESHOLD = 2; // é€£çºŒ 2 æ¬¡æ˜¯æœƒå“¡ -> é€šé
        const FAIL_THRESHOLD = 4;    // é€£çºŒ 4 æ¬¡éæœƒå“¡ -> æ””æˆª
        const MIN_LENGTH = 3;        // è‡³å°‘ 3 ç¢¼æ‰ç®—è»Šç‰Œ
        
        const USER_CONFUSE_TABLE = {
            '6': ['4', 'G', 'B', '8'], '4': ['A', '6'], '2': ['Z', '7'], 'Z': ['2'],
            'B': ['8', 'D', '0'], '8': ['B', '3', 'S'], 'D': ['0', 'O', 'Q'],
            '0': ['D', 'O', 'Q'], 'O': ['0', 'D', 'Q'], '1': ['I', 'L', 'T'], 'I': ['1']
        };
        // =============

        let cvReady = false;
        let whitelistArray = [];
        let isScanning = false;
        let votePool = {};     // æœƒå“¡ç©åˆ†æ± 
        let failCount = 0;     // éæœƒå“¡é€£çºŒæ¬¡æ•¸
        
        const video = document.getElementById('video');
        const startBtn = document.getElementById('startBtn');
        const scanBtn = document.getElementById('scanBtn');
        const statusMsg = document.getElementById('statusMsg');
        const rawTextDisplay = document.getElementById('rawText');
        const logBox = document.getElementById('systemLog');
        const progressBar = document.getElementById('progress-bar');
        const processedCanvas = document.getElementById('processedCanvas');

        function log(msg, type='info') {
            const div = document.createElement('div');
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if(type==='error') div.style.color = '#ff4d4d';
            if(type==='success') div.style.color = '#4dff4d';
            logBox.prepend(div);
        }

        // 0. OpenCV æº–å‚™
        function onOpenCvReady() {
            cvReady = true;
            startBtn.textContent = "1. å•Ÿå‹•ç›¸æ©Ÿ (4K)";
            startBtn.disabled = false;
            log("âœ… OpenCV è¼‰å…¥å®Œæˆ", 'success');
        }

        // 1. è¼‰å…¥è³‡æ–™åº«
        async function loadWhitelist() {
            try {
                const timeStamp = new Date().getTime();
                const response = await fetch('whitelist.txt?t=' + timeStamp);
                if (!response.ok) throw new Error("404");
                const text = await response.text();
                whitelistArray = text.split(/\r?\n/)
                    .map(line => line.trim().replace(/[^a-zA-Z0-9]/g, '').toUpperCase())
                    .filter(item => item.length > 0);
                log(`âœ… è³‡æ–™åº«è¼‰å…¥: ${whitelistArray.length} ç­†`, 'success');
            } catch (err) {
                log(`âŒ è³‡æ–™åº«éŒ¯èª¤: ${err.message}`, 'error');
            }
        }
        loadWhitelist();

        // 2. å•Ÿå‹•ç›¸æ©Ÿ
        startBtn.addEventListener('click', async () => {
            try {
                const constraints = {
                    video: { 
                        facingMode: "environment", 
                        width: { ideal: 1920 }, 
                        height: { ideal: 1080 },
                        focusMode: "continuous"
                    } 
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.onloadedmetadata = () => { 
                    video.play(); 
                    scanBtn.disabled = false; 
                    startBtn.style.display = 'none';
                    log(`ç›¸æ©Ÿå·²å•Ÿå‹• (${video.videoWidth}x${video.videoHeight})`);
                };
            } catch (err) { 
                log(`âŒ ç›¸æ©Ÿå¤±æ•—: ${err.message}`, 'error'); 
            }
        });

        // 3. OpenCV å½±åƒè™•ç†
        function captureAndProcessImage() {
            if (!cvReady) return null;
            try {
                const ctx = processedCanvas.getContext('2d');
                const vw = video.videoWidth;
                const vh = video.videoHeight;
                
                // è£åˆ‡
                const cropW = vw * 0.6; 
                const cropH = cropW * 0.35; 
                const cropX = (vw - cropW) / 2;
                const cropY = (vh - cropH) / 2;

                processedCanvas.width = cropW;
                processedCanvas.height = cropH;
                ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

                let src = cv.imread(processedCanvas);
                let dst = new cv.Mat();
                
                cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
                // è‡ªé©æ‡‰äºŒå€¼åŒ–
                cv.adaptiveThreshold(src, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 31, 2);

                cv.imshow('processedCanvas', dst);
                const dataUrl = processedCanvas.toDataURL('image/png');
                src.delete(); dst.delete();
                return dataUrl;

            } catch (e) {
                return null;
            }
        }

        // 4. å®¹éŒ¯æ¯”å°
        function isFuzzyMatch(scanned, dbItem) {
            if (Math.abs(scanned.length - dbItem.length) > 1) return false;
            let errors = 0;
            let i = 0, j = 0;
            while (i < scanned.length && j < dbItem.length) {
                const S = scanned[i]; const D = dbItem[j];
                if (S === D) { i++; j++; }
                else if (USER_CONFUSE_TABLE[D] && USER_CONFUSE_TABLE[D].includes(S)) { i++; j++; }
                else { errors++; i++; j++; }
            }
            return errors <= 1; 
        }

        // 5. æƒæè¿´åœˆ (å«å¤±æ•—é‚è¼¯)
        async function startScanningLoop() {
            if (isScanning) return;
            isScanning = true;
            votePool = {}; // æ¸…ç©ºæˆåŠŸç©åˆ†
            failCount = 0; // æ¸…ç©ºå¤±æ•—è¨ˆæ•¸
            scanBtn.textContent = "ğŸ›‘ æƒæä¸­...";
            scanBtn.style.backgroundColor = "#dc3545";

            while (isScanning) {
                const dataUrl = captureAndProcessImage();
                if (!dataUrl) { await new Promise(r=>setTimeout(r, 500)); continue; }

                try {
                    const { data: { text } } = await Tesseract.recognize(dataUrl, 'eng', {
                        tessedit_pageseg_mode: '7',
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789- '
                    });

                    let cleanRaw = text.replace(/[\r\n]/g, '');
                    rawTextDisplay.textContent = cleanRaw || "...";

                    let tokens = text.split(/[\s\n]+/);
                    let foundMemberInFrame = false;
                    let foundAnyValidPlate = false; // é€™ä¸€å¹€æœ‰æ²’æœ‰çœ‹åˆ°ä»»ä½•åƒè»Šç‰Œçš„æ±è¥¿

                    // å€™é¸å­—ä¸² (ç”¨æ–¼é¡¯ç¤ºéæœƒå“¡è»Šè™Ÿ)
                    let topCandidate = "";

                    for (let token of tokens) {
                        let scanned = token.replace(/[^A-Z0-9]/g, ''); 
                        // éæ¿¾: è‡³å°‘ 3 ç¢¼ä¸”å¿…é ˆåŒ…å«æ•¸å­— (éæ¿¾ç´”è‹±æ–‡æ‹›ç‰Œ)
                        if (scanned.length < MIN_LENGTH || !/[0-9]/.test(scanned)) continue;

                        foundAnyValidPlate = true;
                        topCandidate = scanned;

                        // æ¯”å°æœƒå“¡
                        for (let member of whitelistArray) {
                            if (isFuzzyMatch(scanned, member)) {
                                foundMemberInFrame = true;
                                log(`æ¯”å°æˆåŠŸ: ${scanned} -> ${member}`);
                                
                                // â˜… ç™¼ç¾æœƒå“¡ -> å¤±æ•—è¨ˆæ•¸å™¨æ­¸é›¶
                                failCount = 0; 

                                if (!votePool[member]) votePool[member] = 0;
                                votePool[member]++;
                                
                                let percent = (votePool[member] / SUCCESS_THRESHOLD) * 100;
                                progressBar.style.width = `${Math.min(percent, 100)}%`;
                                progressBar.style.backgroundColor = "#00ff00";

                                if (votePool[member] >= SUCCESS_THRESHOLD) {
                                    statusMsg.innerHTML = `<div class="match-success">â­• æœƒå“¡é€šè¡Œ<br>${member}</div>`;
                                    log(`ğŸ¯ æœƒå“¡ç¢ºèª: ${member}`, 'success');
                                    stopScan(true);
                                    return; 
                                }
                                break;
                            }
                        }
                        if (foundMemberInFrame) break;
                    }

                    // --- åˆ¤æ–·é‚è¼¯ ---
                    if (!foundMemberInFrame) {
                        // æ²’æ‰¾åˆ°æœƒå“¡ï¼Œä½†æœ‰çœ‹åˆ°åƒè»Šç‰Œçš„æ±è¥¿ -> å¯èƒ½æ˜¯éæœƒå“¡
                        if (foundAnyValidPlate) {
                            failCount++;
                            let progress = (failCount / FAIL_THRESHOLD) * 100;
                            // å¤±æ•—é€²åº¦æ¢ç”¨ç´…è‰²é¡¯ç¤º
                            progressBar.style.width = `${progress}%`;
                            progressBar.style.backgroundColor = "#ff4d4d";
                            
                            statusMsg.textContent = `éæœƒå“¡åµæ¸¬ä¸­ (${failCount}/${FAIL_THRESHOLD})...`;
                            log(`âš ï¸ åµæ¸¬åˆ°æœªçŸ¥è»Šè¼›: ${topCandidate} (${failCount})`);

                            if (failCount >= FAIL_THRESHOLD) {
                                statusMsg.innerHTML = `<div class="match-fail">âŒ éæœƒå“¡è»Š<br>${topCandidate}</div>`;
                                log(`â›” æ””æˆªéæœƒå“¡: ${topCandidate}`, 'error');
                                stopScan(false); // åœæ­¢æƒæ
                                return;
                            }
                        } else {
                            // ä»€éº¼éƒ½æ²’çœ‹åˆ° (æ¨¡ç³Šæˆ–ç„¡å­—) -> ä¸ç®—å¤±æ•—ï¼Œç¶­æŒç¾ç‹€
                            // ä¹Ÿå¯ä»¥é¸æ“‡è®“ç©åˆ†æ…¢æ…¢è¡°é€€
                        }
                    }

                } catch (err) {
                    // Tesseract error
                }

                await new Promise(r => setTimeout(r, 200)); 
            }
        }

        function stopScan(isSuccess) {
            isScanning = false;
            scanBtn.textContent = isSuccess ? "âœ… å®Œæˆ (é»æ“Šé‡ç½®)" : "â›” å·²æ””æˆª (é»æ“Šé‡ç½®)";
            scanBtn.style.backgroundColor = isSuccess ? "#28a745" : "#ff4d4d";
        }

        scanBtn.addEventListener('click', () => {
            if (isScanning) {
                // æ‰‹å‹•æš«åœ
                isScanning = false;
                scanBtn.textContent = "ğŸ“¸ é–‹å§‹è¾¨è­˜";
                scanBtn.style.backgroundColor = "#28a745";
                statusMsg.textContent = "å·²æš«åœ";
                progressBar.style.width = "0%";
            } else {
                // é–‹å§‹/é‡ç½®
                statusMsg.textContent = "æƒæä¸­...";
                startScanningLoop();
            }
        });

    </script>
</body>
</html>
